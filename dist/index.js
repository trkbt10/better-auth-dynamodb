import { createAdapterFactory as se } from "@better-auth/core/db/adapter";
import { randomUUID as Ge } from "node:crypto";
import { QueryCommand as Te, ScanCommand as Ie, BatchGetCommand as Ue, TransactWriteCommand as He, PutCommand as Qe, DeleteCommand as We, UpdateCommand as Je } from "@aws-sdk/lib-dynamodb";
import { getAuthTables as ze } from "@better-auth/core/db";
import { CreateTableCommand as Ye, waitUntilTableExists as Xe, ListTablesCommand as Ze, DescribeTableCommand as et, UpdateTableCommand as we } from "@aws-sdk/client-dynamodb";
const tt = {
  account: [{ partitionKey: "providerId", sortKey: "accountId" }],
  session: [
    { partitionKey: "userId", sortKey: "createdAt" },
    { partitionKey: "token", sortKey: "createdAt" }
  ],
  verification: [{ partitionKey: "identifier", sortKey: "createdAt" }]
}, nt = {
  /**
   * deviceCode table from deviceAuthorization plugin.
   *
   * The plugin schema does not include references/index for userId despite
   * documentation stating it references the user table.
   *
   * @see https://www.better-auth.com/docs/plugins/device-authorization
   */
  deviceCode: {
    userId: {
      index: !0,
      references: { model: "user", field: "id" }
    }
  }
}, Zn = (e, t) => {
  const n = ze(e);
  return Ee(n, t);
}, Ee = (e, t) => {
  const n = [], i = it(
    t?.disableAutoCompositeIndexes ? {} : tt,
    t?.compositeIndexes ?? {}
  ), a = at(
    t?.disableSchemaExtensions ? {} : nt,
    t?.schemaExtensions ?? {}
  );
  for (const [r, s] of Object.entries(e)) {
    const o = s.modelName ?? r, l = [], m = [
      { AttributeName: "id", AttributeType: "S" }
    ], c = [], u = /* @__PURE__ */ new Set(["id"]), d = /* @__PURE__ */ new Set(), f = (g) => {
      u.has(g) || (m.push({
        AttributeName: g,
        AttributeType: "S"
      }), u.add(g));
    }, b = i[o] ?? [], h = /* @__PURE__ */ new Set();
    for (const g of b) {
      const x = g.partitionKey, S = g.sortKey, A = `${o}_${x}_${S}_idx`;
      d.has(A) || (f(x), f(S), c.push({
        IndexName: A,
        KeySchema: [
          { AttributeName: x, KeyType: "HASH" },
          { AttributeName: S, KeyType: "RANGE" }
        ],
        Projection: { ProjectionType: "ALL" }
      }), l.push({
        indexName: A,
        partitionKey: x,
        sortKey: S
      }), d.add(A), h.add(x));
    }
    const v = t?.indexReferences !== !1, T = a[o] ?? {};
    for (const [g, x] of Object.entries(s.fields)) {
      const S = x.fieldName ?? g, A = T[g], I = A?.index === !0 ? !0 : x.index === !0, D = A?.unique === !0 ? !0 : x.unique === !0, E = A?.references ?? x.references;
      if ((I ? !0 : D) ? !0 : E !== void 0 ? v : !1) {
        if (h.has(S))
          continue;
        const K = `${o}_${S}_idx`;
        if (d.has(K))
          continue;
        f(S), c.push({
          IndexName: K,
          KeySchema: [{ AttributeName: S, KeyType: "HASH" }],
          Projection: { ProjectionType: "ALL" }
        }), l.push({
          indexName: K,
          partitionKey: S
        }), d.add(K);
      }
    }
    n.push({
      tableName: o,
      tableDefinition: {
        attributeDefinitions: m,
        keySchema: [{ AttributeName: "id", KeyType: "HASH" }],
        billingMode: "PAY_PER_REQUEST",
        globalSecondaryIndexes: c.length > 0 ? c : void 0
      },
      indexMappings: l
    });
  }
  return n;
}, it = (e, t) => {
  const n = { ...e };
  for (const [i, a] of Object.entries(t))
    n[i] ? n[i] = [...n[i], ...a] : n[i] = a;
  return n;
}, at = (e, t) => {
  const n = {};
  for (const [i, a] of Object.entries(e))
    n[i] = { ...a };
  for (const [i, a] of Object.entries(t))
    if (n[i])
      for (const [r, s] of Object.entries(a))
        n[i][r] = {
          ...n[i][r],
          ...s
        };
    else
      n[i] = { ...a };
  return n;
}, rt = (e, t) => t ? e.map((n) => ({
  ...n,
  tableName: `${t}${n.tableName}`
})) : e, st = (e) => {
  const t = Ee(e.tables, e.schemaOptions), n = e.file ?? "dynamodb-tables.ts", i = rt(t, e.tableNamePrefix), a = JSON.stringify(i, null, 2);
  return `/**
 * DynamoDB Table Schemas for Better Auth
 *
 * Generated by: npx @better-auth/cli generate
 * Run this script to create/update DynamoDB tables:
 *   npx ts-node ${n}
 */
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { applyTableSchemas } from "better-auth-dynamodb";
import type { TableSchema } from "better-auth-dynamodb";

const tableSchemas: TableSchema[] = ${a};

const client = new DynamoDBClient({});

await applyTableSchemas({ client, tables: tableSchemas });
console.log("DynamoDB tables created/updated successfully.");
`;
};
class N extends Error {
  constructor(t, n) {
    super(n), this.code = t, this.name = "DynamoDBAdapterError";
  }
}
const pe = (e) => e ? e.toLowerCase() : "eq", oe = (e) => typeof e == "number" && !Number.isNaN(e), k = (e) => typeof e == "string", ot = (e, t) => e instanceof Date && t instanceof Date ? e.getTime() - t.getTime() : oe(e) && oe(t) ? e - t : k(e) && k(t) ? e < t ? -1 : e > t ? 1 : 0 : null, ke = (e) => Array.isArray(e) ? e : [e], $ = (e) => {
  const t = e.appendValue(e.value);
  return `${e.fieldToken} ${e.operator} ${t}`;
}, V = (e) => {
  const t = ot(e.fieldValue, e.value);
  return t === null ? !1 : e.operator === "gt" ? t > 0 : e.operator === "gte" ? t >= 0 : e.operator === "lt" ? t < 0 : t <= 0;
}, le = (e) => {
  const n = ke(e.value).map(
    (a) => e.appendValue(a)
  ), i = `${e.fieldToken} IN (${n.join(", ")})`;
  return e.negate ? `NOT (${i})` : i;
}, ue = (e) => {
  const n = ke(e.value).some((i) => i === e.fieldValue);
  return e.negate ? !n : n;
}, lt = (e) => {
  const t = e.appendValue(e.value);
  return `contains(${e.fieldToken}, ${t})`;
}, ut = (e) => Array.isArray(e.fieldValue) || k(e.fieldValue) && k(e.value) ? e.fieldValue.includes(e.value) : !1, ct = (e) => {
  const t = e.appendValue(e.value);
  return `begins_with(${e.fieldToken}, ${t})`;
}, dt = (e) => k(e.fieldValue) && k(e.value) ? e.fieldValue.startsWith(e.value) : !1, mt = (e) => k(e.fieldValue) && k(e.value) ? e.fieldValue.endsWith(e.value) : !1, ft = {
  eq: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => {
      const t = e.appendValue(e.value);
      return `${e.fieldToken} = ${t}`;
    },
    evaluate: (e) => e.fieldValue === e.value
  },
  ne: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => {
      const t = e.appendValue(e.value);
      return `${e.fieldToken} <> ${t}`;
    },
    evaluate: (e) => e.fieldValue !== e.value
  },
  gt: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => $({
      fieldToken: e.fieldToken,
      value: e.value,
      operator: ">",
      appendValue: e.appendValue
    }),
    evaluate: (e) => V({
      fieldValue: e.fieldValue,
      value: e.value,
      operator: "gt"
    })
  },
  gte: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => $({
      fieldToken: e.fieldToken,
      value: e.value,
      operator: ">=",
      appendValue: e.appendValue
    }),
    evaluate: (e) => V({
      fieldValue: e.fieldValue,
      value: e.value,
      operator: "gte"
    })
  },
  lt: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => $({
      fieldToken: e.fieldToken,
      value: e.value,
      operator: "<",
      appendValue: e.appendValue
    }),
    evaluate: (e) => V({
      fieldValue: e.fieldValue,
      value: e.value,
      operator: "lt"
    })
  },
  lte: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => $({
      fieldToken: e.fieldToken,
      value: e.value,
      operator: "<=",
      appendValue: e.appendValue
    }),
    evaluate: (e) => V({
      fieldValue: e.fieldValue,
      value: e.value,
      operator: "lte"
    })
  },
  in: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => le({
      fieldToken: e.fieldToken,
      value: e.value,
      appendValue: e.appendValue,
      negate: !1
    }),
    evaluate: (e) => ue({
      fieldValue: e.fieldValue,
      value: e.value,
      negate: !1
    })
  },
  not_in: {
    requiresClientFilter: !1,
    buildFilterExpression: (e) => le({
      fieldToken: e.fieldToken,
      value: e.value,
      appendValue: e.appendValue,
      negate: !0
    }),
    evaluate: (e) => ue({
      fieldValue: e.fieldValue,
      value: e.value,
      negate: !0
    })
  },
  contains: {
    requiresClientFilter: !1,
    buildFilterExpression: lt,
    evaluate: ut
  },
  starts_with: {
    requiresClientFilter: !1,
    buildFilterExpression: ct,
    evaluate: dt
  },
  ends_with: {
    requiresClientFilter: !0,
    buildFilterExpression: void 0,
    evaluate: mt
  }
}, z = (e) => {
  const t = pe(e), n = ft[t];
  if (!n)
    throw new N(
      "UNSUPPORTED_OPERATOR",
      `Unsupported operator: ${e}`
    );
  return n;
}, De = (e) => z(e).requiresClientFilter, Y = (e) => pe(e), Pe = (e) => {
  if (!e)
    throw new N(
      "MISSING_WHERE_INPUT",
      "normalizeWhere requires explicit props."
    );
  const { where: t } = e;
  if (!t || t.length === 0)
    return [];
  const n = (i) => i && i.toUpperCase() === "OR" ? "OR" : "AND";
  return t.map((i) => {
    const a = Y(
      i.operator
    ), r = n(i.connector);
    return {
      field: i.field,
      operator: a,
      value: i.value,
      connector: r,
      requiresClientFilter: De(i.operator)
    };
  });
}, Ke = (e) => e.getFieldName({ model: e.model, field: "id" }), ce = (e) => e.where.find(
  (t) => t.operator === e.operator && t.field === e.primaryKeyName
), yt = (e) => {
  const t = (r) => r ? e.where.some(
    (s) => s.operator === "eq" && s.field === r
  ) : !1, n = (r) => {
    if (e.indexKeySchemaResolver)
      return e.indexKeySchemaResolver({ model: e.model, indexName: r });
  }, a = e.where.filter((r) => r.operator === "eq").map((r) => {
    const s = e.indexNameResolver({
      model: e.model,
      field: r.field
    });
    if (!s)
      return null;
    const l = n(s)?.sortKey, m = t(l);
    return {
      entry: r,
      indexName: s,
      score: m ? 2 : 1
    };
  }).filter((r) => r !== null).reduce((r, s) => !r || s.score > r.score ? s : r, void 0);
  if (a)
    return { entry: a.entry, indexName: a.indexName };
}, bt = (e) => {
  for (const t of e.where) {
    if (t.operator !== "in" || !Array.isArray(t.value))
      continue;
    const n = e.indexNameResolver({
      model: e.model,
      field: t.field
    });
    if (n)
      return { entry: t, indexName: n };
  }
}, Nt = (e) => {
  if (!e)
    throw new N(
      "MISSING_STRATEGY_INPUT",
      "resolveBaseStrategy requires explicit props."
    );
  const t = e.where.filter((o) => o.connector === "AND"), n = Ke({
    model: e.model,
    getFieldName: e.getFieldName
  });
  if (ce({
    where: t,
    primaryKeyName: n,
    operator: "eq"
  }))
    return { kind: "query", key: "pk" };
  const a = yt({
    where: t,
    model: e.model,
    indexNameResolver: e.adapterConfig.indexNameResolver,
    indexKeySchemaResolver: e.adapterConfig.indexKeySchemaResolver
  });
  if (a)
    return { kind: "query", key: "gsi", indexName: a.indexName };
  const r = bt({
    where: t,
    model: e.model,
    indexNameResolver: e.adapterConfig.indexNameResolver
  });
  if (r)
    return {
      kind: "multi-query",
      indexName: r.indexName,
      field: r.entry.field
    };
  const s = ce({
    where: t,
    primaryKeyName: n,
    operator: "in"
  });
  return s && Array.isArray(s.value) ? { kind: "batch-get" } : { kind: "scan" };
}, Me = (e) => {
  if (!e)
    throw new N(
      "MISSING_JOIN_STRATEGY_INPUT",
      "resolveJoinStrategyHint requires explicit props."
    );
  const t = Ke({
    model: e.model,
    getFieldName: e.getFieldName
  });
  if (e.joinField === t)
    return { kind: "query", key: "pk" };
  const n = e.adapterConfig.indexNameResolver({
    model: e.model,
    field: e.joinField
  });
  return n ? { kind: "query", key: "gsi", indexName: n } : { kind: "scan" };
}, xt = (e) => {
  if (!e)
    throw new N(
      "MISSING_JOIN_STRATEGY_INPUT",
      "resolveJoinStrategy requires explicit props."
    );
  const t = Me({
    joinField: e.joinField,
    model: e.model,
    getFieldName: e.getFieldName,
    adapterConfig: e.adapterConfig
  });
  return t.kind === "query" && t.key === "pk" && e.baseValues.length > 1 ? { kind: "batch-get" } : t;
}, gt = (e) => {
  if (!e)
    throw new N(
      "MISSING_JOIN_PLAN_INPUT",
      "resolveJoinPlan requires explicit props."
    );
  return !e.join || Object.keys(e.join).length === 0 ? [] : Object.entries(e.join).map(([t, n]) => {
    const i = Me({
      joinField: n.on.to,
      model: t,
      getFieldName: e.getFieldName,
      adapterConfig: e.adapterConfig
    });
    return {
      modelKey: t,
      model: t,
      relation: n.relation ?? "one-to-many",
      on: n.on,
      limit: n.limit,
      select: void 0,
      strategy: i
    };
  });
}, ht = (e) => {
  const t = e.where.some(
    (i) => i.connector === "OR"
  ), n = e.where.some(
    (i) => i.requiresClientFilter
  );
  return {
    hasOrConnector: t,
    hasClientOnlyOperator: n,
    requiresSelectSupplement: e.requiresSelectSupplement
  };
}, St = (e) => {
  if (e.requiresClientFilter || e.requiresClientSort || e.limit === void 0)
    return;
  const t = e.offset ?? 0;
  return e.limit + t;
}, vt = (e) => {
  if (e.sortBy)
    return {
      field: e.getFieldName({ model: e.model, field: e.sortBy.field }),
      direction: e.sortBy.direction
    };
}, At = (e) => {
  if (!e.normalizedSort || e.baseStrategy.kind !== "query" || e.baseStrategy.key !== "gsi" || !e.baseStrategy.indexName || !e.adapterConfig.indexKeySchemaResolver)
    return;
  const t = e.adapterConfig.indexKeySchemaResolver({
    model: e.model,
    indexName: e.baseStrategy.indexName
  });
  if (!(!t || !t.sortKey) && t.sortKey === e.normalizedSort.field)
    return e.normalizedSort;
}, Ct = (e) => !(!e.normalizedSort || e.serverSort), Tt = (e) => {
  if (!e.select || e.select.length === 0)
    return { select: e.select, requiresSelectSupplement: !1 };
  if (e.joins.length === 0)
    return { select: [...e.select], requiresSelectSupplement: !1 };
  const t = {
    select: [...e.select],
    selectedFields: new Set(
      e.select.map(
        (i) => e.getFieldName({ model: e.model, field: i })
      )
    ),
    requiresSelectSupplement: !1
  }, n = e.joins.reduce((i, a) => i.selectedFields.has(a.on.from) ? i : (i.selectedFields.add(a.on.from), i.select.push(a.on.from), {
    ...i,
    requiresSelectSupplement: !0
  }), t);
  return {
    select: n.select,
    requiresSelectSupplement: n.requiresSelectSupplement
  };
}, O = (e) => {
  if (!e)
    throw new N(
      "MISSING_QUERY_PLAN_INPUT",
      "buildQueryPlan requires explicit props."
    );
  const t = Pe({ where: e.where }), n = gt({
    join: e.join,
    getFieldName: e.getFieldName,
    adapterConfig: e.adapterConfig
  }), i = Tt({
    select: e.select,
    joins: n,
    getFieldName: e.getFieldName,
    model: e.model
  }), a = ht({
    where: t,
    requiresSelectSupplement: i.requiresSelectSupplement
  }), r = Nt({
    model: e.model,
    where: t,
    getFieldName: e.getFieldName,
    adapterConfig: e.adapterConfig
  }), s = n.reduce(
    (d, f) => (d[f.modelKey] = f.strategy, d),
    {}
  ), o = a.hasClientOnlyOperator, l = vt({
    sortBy: e.sortBy,
    getFieldName: e.getFieldName,
    model: e.model
  }), m = At({
    model: e.model,
    baseStrategy: r,
    normalizedSort: l,
    adapterConfig: e.adapterConfig
  }), c = Ct({
    normalizedSort: l,
    serverSort: m
  }), u = {
    baseStrategy: r,
    joinStrategies: s,
    requiresClientFilter: o,
    requiresClientSort: c,
    serverSort: m,
    fetchLimit: St({
      limit: e.limit,
      offset: e.offset,
      requiresClientFilter: o,
      requiresClientSort: c
    })
  };
  return {
    base: {
      model: e.model,
      where: t,
      select: i.select,
      sort: l,
      limit: e.limit,
      offset: e.offset
    },
    joins: n,
    execution: u,
    constraints: a
  };
}, de = (e) => {
  const t = z(e.condition.operator), n = e.item[e.condition.fieldName];
  return t.evaluate({ fieldValue: n, value: e.condition.value });
}, It = (e) => e.map((t) => ({
  fieldName: t.field,
  operator: Y(t.operator),
  value: t.value,
  connector: t.connector
})), wt = (e) => {
  const { item: t, conditions: n } = e;
  if (n.length === 0)
    return !0;
  const i = n.filter(
    (u) => u.connector === "AND"
  ), a = n.filter(
    (u) => u.connector === "OR"
  ), r = i.map(
    (u) => de({ item: t, condition: u })
  ), s = a.map(
    (u) => de({ item: t, condition: u })
  ), o = (u) => u.length === 0 ? !0 : u.every(Boolean), l = (u) => u.length === 0 ? !0 : u.some(Boolean);
  return !(!o(r) || !l(s));
}, Fe = (e) => {
  if (!e.where || e.where.length === 0)
    return e.items;
  const t = It(e.where);
  return e.items.filter((n) => wt({ item: n, conditions: t }));
}, Et = (e) => e.requiresClientFilter ? Fe({ items: e.items, where: e.where }) : e.items, pt = (e) => e === "desc" ? -1 : 1, kt = (e, t) => {
  if (e.length <= 1)
    return e;
  const n = pt(t.direction), i = (a) => a == null;
  return [...e].sort((a, r) => {
    const s = a[t.field], o = r[t.field];
    return s === o ? 0 : i(s) ? 1 * n : i(o) ? -1 * n : s > o ? 1 * n : s < o ? -1 * n : 0;
  });
}, Dt = (e, t) => t.sortBy ? kt(e, {
  field: t.sortBy.field,
  direction: t.sortBy.direction
}) : e, Pt = (e) => {
  if (!e.select || e.select.length === 0)
    return e.items;
  const t = e.select.map(
    (n) => e.getFieldName({ model: e.model, field: n })
  );
  return e.items.map((n) => {
    const i = t.reduce(
      (r, s) => (s in n && (r[s] = n[s]), r),
      {}
    ), a = e.joinKeys.reduce(
      (r, s) => (s in n && (r[s] = n[s]), r),
      {}
    );
    return { ...i, ...a };
  });
}, w = (e) => {
  const { model: t, getDefaultModelName: n, config: i } = e, a = n(t);
  if (i.tableNameResolver)
    return i.tableNameResolver(a);
  if (i.tableNamePrefix !== void 0)
    return `${i.tableNamePrefix}${a}`;
  throw new N(
    "MISSING_TABLE_RESOLVER",
    "DynamoDB adapter requires tableNameResolver or tableNamePrefix."
  );
}, Kt = (e, t, n) => {
  const i = `:v${t.index}`;
  return t.index += 1, n[i] = e, i;
}, Mt = (e) => e && e.toUpperCase() === "OR" ? "OR" : "AND", Ft = (e) => {
  for (const t of e)
    if (De(t.operator))
      return !0;
  return !1;
}, Ot = (e) => {
  const t = z(e.operator);
  if (!t.buildFilterExpression)
    throw new N(
      "UNSUPPORTED_OPERATOR",
      "Filter expression builder is missing."
    );
  const n = {
    fieldToken: e.fieldToken,
    value: e.value,
    appendValue: (i) => Kt(i, e.state, e.values)
  };
  return t.buildFilterExpression(n);
}, $t = (e) => {
  const { andExpressions: t, orExpressions: n } = e, i = t.join(" AND "), a = n.join(" OR ");
  if (i && a)
    return `(${i}) AND (${a})`;
  if (i)
    return i;
  if (a)
    return a;
}, P = (e) => {
  const { where: t, model: n, getFieldName: i } = e;
  if (!t || t.length === 0)
    return {
      filterExpression: void 0,
      expressionAttributeNames: {},
      expressionAttributeValues: {},
      requiresClientFilter: !1
    };
  if (Ft(t))
    return {
      filterExpression: void 0,
      expressionAttributeNames: {},
      expressionAttributeValues: {},
      requiresClientFilter: !0
    };
  const a = {}, r = {}, s = { index: 0 }, o = t.map((u, d) => {
    const f = i({ model: n, field: u.field }), b = `#f${d}`;
    a[b] = f;
    const h = Ot({
      fieldToken: b,
      operator: u.operator,
      value: u.value,
      state: s,
      values: r
    });
    return {
      connector: Mt(u.connector),
      expression: h
    };
  }), l = o.filter((u) => u.connector === "AND").map((u) => u.expression), m = o.filter((u) => u.connector === "OR").map((u) => u.expression);
  return {
    filterExpression: $t({
      andExpressions: l,
      orExpressions: m
    }),
    expressionAttributeNames: a,
    expressionAttributeValues: r,
    requiresClientFilter: !1
  };
}, _ = (e) => {
  const { model: t, where: n, getFieldName: i, indexNameResolver: a, indexKeySchemaResolver: r } = e;
  if (!n || n.length === 0)
    return null;
  const s = i({ model: t, field: "id" }), o = (y) => y && y.toUpperCase() === "OR" ? "OR" : "AND", l = n.map((y) => ({
    entry: y,
    operator: Y(y.operator),
    fieldName: i({ model: t, field: y.field }),
    connector: o(y.connector)
  })), m = l.find(
    ({ operator: y, fieldName: C, connector: p }) => y === "eq" && p === "AND" && C === s
  );
  if (m) {
    const y = n.filter(
      (C) => C !== m.entry
    );
    return {
      keyConditionExpression: "#pk = :pk",
      expressionAttributeNames: { "#pk": s },
      expressionAttributeValues: {
        ":pk": m.entry.value
      },
      remainingWhere: y
    };
  }
  const c = (y) => y ? l.some((C) => C.connector !== "AND" || C.operator !== "eq" ? !1 : C.fieldName === y) : !1, u = (y) => {
    if (r)
      return r({ model: t, indexName: y });
  }, b = l.filter((y) => y.connector !== "AND" || y.operator !== "eq" ? !1 : !!a({ model: t, field: y.entry.field })).map((y) => {
    const C = a({ model: t, field: y.entry.field });
    if (!C)
      return null;
    const j = u(C)?.sortKey, Be = c(j);
    return {
      candidate: y,
      indexName: C,
      score: Be ? 2 : 1
    };
  }).filter((y) => y !== null).reduce((C, p) => !C || p.score > C.score ? p : C, void 0);
  if (!b)
    return null;
  const h = b.indexName, v = b.candidate, T = () => {
    if (r)
      return r({ model: t, indexName: h });
  }, g = (y) => {
    if (y)
      return l.find(
        ({ operator: C, fieldName: p, connector: j }) => C === "eq" && j === "AND" && p === y
      );
  }, x = (y) => y ? "#pk = :pk AND #sk = :sk" : "#pk = :pk", S = (y) => y.sortKey ? {
    "#pk": y.partitionKey,
    "#sk": y.sortKey
  } : { "#pk": y.partitionKey }, A = (y) => y.sortValue === void 0 ? { ":pk": y.partitionValue } : {
    ":pk": y.partitionValue,
    ":sk": y.sortValue
  }, D = T()?.sortKey, E = g(D), F = (y) => {
    if (y)
      return D;
  }, ie = (y) => {
    if (y)
      return y.entry.value;
  }, ae = n.filter(
    (y) => y !== v.entry && y !== E?.entry
  ), re = x(
    !!E
  ), K = S({
    partitionKey: v.fieldName,
    sortKey: F(E)
  }), je = A({
    partitionValue: v.entry.value,
    sortValue: ie(E)
  });
  return {
    keyConditionExpression: re,
    expressionAttributeNames: K,
    expressionAttributeValues: je,
    indexName: h,
    remainingWhere: ae
  };
}, q = (e, t) => {
  t.filterExpression && (e.FilterExpression = t.filterExpression), Object.keys(t.expressionAttributeNames).length > 0 && (e.ExpressionAttributeNames = t.expressionAttributeNames), Object.keys(t.expressionAttributeValues).length > 0 && (e.ExpressionAttributeValues = t.expressionAttributeValues);
}, L = async (e) => {
  const t = {
    token: e.initialToken,
    pageCount: 0
  };
  for (; ; ) {
    e.maxPages !== void 0 && t.pageCount >= e.maxPages && e.onMaxPages(), t.pageCount += 1;
    const n = await e.fetchPage(t.token, t.pageCount), i = n.nextToken, a = n.shouldStop === !0;
    if (t.token = i, a || !t.token)
      break;
  }
}, Oe = (e, t) => {
  if (e === void 0)
    return;
  const n = e - t;
  return n <= 0 ? 0 : n;
}, Q = async (e) => {
  const t = [], n = { pages: 0 };
  if (await L({
    fetchPage: async (i) => {
      n.pages += 1;
      const a = Oe(e.limit, t.length);
      if (a === 0)
        return { shouldStop: !0 };
      const r = {
        TableName: e.tableName,
        KeyConditionExpression: e.keyConditionExpression
      };
      e.indexName && (r.IndexName = e.indexName), q(r, {
        filterExpression: e.filterExpression,
        expressionAttributeNames: e.expressionAttributeNames,
        expressionAttributeValues: e.expressionAttributeValues
      }), i && (r.ExclusiveStartKey = i), a !== void 0 && (r.Limit = a), e.scanIndexForward !== void 0 && (r.ScanIndexForward = e.scanIndexForward);
      const s = await e.documentClient.send(
        new Te(r)
      ), o = s.Items ?? [];
      return t.push(...o), e.operationStats?.recordQuery({
        tableName: e.tableName,
        items: o.length
      }), { nextToken: s.LastEvaluatedKey ?? void 0 };
    }
  }), e.explainDynamoOperations) {
    const i = e.limit === void 0 ? "∞" : String(e.limit), a = e.filterExpression ? "yes" : "no", r = e.indexName ?? "(primary)";
    console.log(
      `DDB-OP QUERY table=${e.tableName} index=${r} pages=${n.pages} items=${t.length} limit=${i} filter=${a}`
    );
  }
  return t;
}, Vt = async (e) => {
  const t = { count: 0 }, n = { pages: 0 };
  if (await L({
    fetchPage: async (i) => {
      n.pages += 1;
      const a = {
        TableName: e.tableName,
        KeyConditionExpression: e.keyConditionExpression,
        Select: "COUNT"
      };
      e.indexName && (a.IndexName = e.indexName), q(a, {
        filterExpression: e.filterExpression,
        expressionAttributeNames: e.expressionAttributeNames,
        expressionAttributeValues: e.expressionAttributeValues
      }), i && (a.ExclusiveStartKey = i);
      const r = await e.documentClient.send(
        new Te(a)
      ), s = r.Count ?? 0;
      return t.count += s, e.operationStats?.recordQuery({
        tableName: e.tableName,
        items: s
      }), { nextToken: r.LastEvaluatedKey ?? void 0 };
    }
  }), e.explainDynamoOperations) {
    const i = e.filterExpression ? "yes" : "no", a = e.indexName ?? "(primary)";
    console.log(
      `DDB-OP QUERY-COUNT table=${e.tableName} index=${a} pages=${n.pages} count=${t.count} filter=${i}`
    );
  }
  return t.count;
}, $e = async (e) => {
  const t = [], n = { pages: 0 };
  if (await L({
    maxPages: e.maxPages ?? Number.POSITIVE_INFINITY,
    onMaxPages: () => {
      throw new N(
        "SCAN_PAGE_LIMIT",
        "Scan exceeded the configured page limit."
      );
    },
    fetchPage: async (i) => {
      n.pages += 1;
      const a = Oe(e.limit, t.length);
      if (a === 0)
        return { shouldStop: !0 };
      const r = {
        TableName: e.tableName
      };
      q(r, {
        filterExpression: e.filterExpression,
        expressionAttributeNames: e.expressionAttributeNames,
        expressionAttributeValues: e.expressionAttributeValues
      }), i && (r.ExclusiveStartKey = i), a !== void 0 && (r.Limit = a);
      const s = await e.documentClient.send(
        new Ie(r)
      ), o = s.Items ?? [];
      return t.push(...o), e.operationStats?.recordScan({
        tableName: e.tableName,
        items: o.length
      }), { nextToken: s.LastEvaluatedKey ?? void 0 };
    }
  }), e.explainDynamoOperations) {
    const i = e.maxPages === void 0 ? "∞" : String(e.maxPages), a = e.limit === void 0 ? "∞" : String(e.limit), r = e.filterExpression ? "yes" : "no";
    console.log(
      `DDB-OP SCAN table=${e.tableName} pages=${n.pages} items=${t.length} limit=${a} maxPages=${i} filter=${r}`
    );
  }
  return t;
}, Rt = async (e) => {
  const t = { count: 0 }, n = { pages: 0 };
  if (await L({
    maxPages: e.maxPages ?? Number.POSITIVE_INFINITY,
    onMaxPages: () => {
      throw new N(
        "SCAN_PAGE_LIMIT",
        "Scan exceeded the configured page limit."
      );
    },
    fetchPage: async (i) => {
      n.pages += 1;
      const a = {
        TableName: e.tableName,
        Select: "COUNT"
      };
      q(a, {
        filterExpression: e.filterExpression,
        expressionAttributeNames: e.expressionAttributeNames,
        expressionAttributeValues: e.expressionAttributeValues
      }), i && (a.ExclusiveStartKey = i);
      const r = await e.documentClient.send(
        new Ie(a)
      ), s = r.Count ?? 0;
      return t.count += s, e.operationStats?.recordScan({
        tableName: e.tableName,
        items: s
      }), { nextToken: r.LastEvaluatedKey ?? void 0 };
    }
  }), e.explainDynamoOperations) {
    const i = e.maxPages === void 0 ? "∞" : String(e.maxPages), a = e.filterExpression ? "yes" : "no";
    console.log(
      `DDB-OP SCAN-COUNT table=${e.tableName} pages=${n.pages} count=${t.count} maxPages=${i} filter=${a}`
    );
  }
  return t.count;
}, _t = (e, t) => {
  const n = Math.ceil(e.length / t);
  return Array.from(
    { length: n },
    (i, a) => e.slice(a * t, (a + 1) * t)
  );
}, qt = (e, t) => t.map((n) => ({ [e]: n })), Lt = (e) => {
  const t = e.unprocessed?.[e.tableName]?.Keys;
  return t || [];
}, X = async (e) => {
  if (e.keys.length === 0)
    return [];
  const t = e.maxAttempts ?? 5;
  if (t <= 0)
    throw new N(
      "INVALID_BATCH_GET_ATTEMPTS",
      "BatchGet requires maxAttempts > 0."
    );
  const n = e.backoffBaseDelayMs ?? 10, i = e.backoffMaxDelayMs ?? 200;
  if (n < 0 || i < 0)
    throw new N(
      "INVALID_BATCH_GET_BACKOFF",
      "BatchGet backoff delays must be >= 0."
    );
  const a = [], r = _t(e.keys, 100), s = { requests: 0, retries: 0 }, o = async (d) => {
    d <= 0 || await new Promise((f) => {
      setTimeout(() => f(), d);
    });
  }, l = (d) => {
    if (d <= 0)
      return 0;
    const f = n * Math.pow(2, d - 1);
    return Math.min(i, f);
  }, m = (d) => {
    if (typeof d != "object" || d === null)
      return;
    const f = d;
    if (typeof f.name == "string")
      return f.name;
    if (typeof f.code == "string")
      return f.code;
  }, c = (d) => {
    const f = m(d);
    return f ? (/* @__PURE__ */ new Set([
      "ProvisionedThroughputExceededException",
      "ThrottlingException",
      "RequestLimitExceeded",
      "TooManyRequestsException",
      "InternalServerError",
      "ServiceUnavailable"
    ])).has(f) : !1;
  }, u = async (d, f) => {
    if (d.length === 0)
      return [];
    if (f >= t)
      throw new N(
        "BATCH_GET_UNPROCESSED",
        "Failed to resolve unprocessed keys after retries."
      );
    const b = async (x, S) => {
      s.requests += 1, S > 0 && (s.retries += 1);
      try {
        return await e.documentClient.send(
          new Ue({
            RequestItems: {
              [e.tableName]: {
                Keys: x
              }
            }
          })
        );
      } catch (A) {
        if (e.operationStats?.recordBatchGet({
          tableName: e.tableName,
          keys: x.length,
          items: 0,
          isRetry: S > 0
        }), !c(A))
          throw A;
        const I = S + 1;
        if (I >= t)
          throw A;
        return await o(l(I)), b(x, I);
      }
    }, v = await b(d, f), T = v.Responses?.[e.tableName] ?? [];
    e.operationStats?.recordBatchGet({
      tableName: e.tableName,
      keys: d.length,
      items: T.length,
      isRetry: f > 0
    });
    const g = Lt({
      unprocessed: v.UnprocessedKeys,
      tableName: e.tableName
    });
    if (g.length > 0) {
      const x = f + 1;
      if (x >= t)
        throw new N(
          "BATCH_GET_UNPROCESSED",
          "Failed to resolve unprocessed keys after retries."
        );
      await o(l(x));
      const S = await u(g, x);
      return [...T, ...S];
    }
    return T;
  };
  for (const d of r) {
    const f = qt(e.keyField, d), b = await u(f, 0);
    a.push(...b);
  }
  if (e.explainDynamoOperations) {
    const d = Math.ceil(e.keys.length / 100);
    console.log(
      `DDB-OP BATCH-GET table=${e.tableName} key=${e.keyField} keys=${e.keys.length} chunks=${d} requests=${s.requests} retries=${s.retries} items=${a.length}`
    );
  }
  return a;
}, jt = (e) => e.relation === "one-to-one" ? 1 : e.limit !== void 0 ? e.limit : 100, Bt = (e) => {
  if (!(e.baseValues.length > 1))
    return e.limit;
}, Gt = (e) => {
  if (e.adapterConfig.scanPageLimitMode === "unbounded")
    return Number.POSITIVE_INFINITY;
  if (e.adapterConfig.scanMaxPages === void 0)
    throw new N(
      "MISSING_SCAN_LIMIT",
      "Join scan requires scanMaxPages."
    );
  return e.adapterConfig.scanMaxPages;
}, Ut = (e) => {
  const t = e.items.map((n) => n[e.field]).filter((n) => n !== void 0);
  return Array.from(new Set(t));
}, Ht = (e) => {
  const t = /* @__PURE__ */ new Map();
  for (const n of e.items) {
    const i = n[e.field];
    if (i === void 0)
      continue;
    const a = t.get(i) ?? [];
    t.set(i, [...a, n]);
  }
  return t;
}, Qt = (e) => e === "one-to-one" ? null : [], Wt = (e, t) => t === void 0 ? [] : e.get(t) ?? [], me = (e) => [
  {
    field: e.field,
    operator: e.operator,
    value: e.value,
    connector: "AND"
  }
], Jt = async (e) => {
  const t = w({
    model: e.model,
    getDefaultModelName: e.getDefaultModelName,
    config: e.adapterConfig
  }), n = _({
    model: e.model,
    where: e.where,
    getFieldName: e.getFieldName,
    indexNameResolver: e.adapterConfig.indexNameResolver,
    indexKeySchemaResolver: e.adapterConfig.indexKeySchemaResolver
  });
  if (!n)
    throw new N(
      "MISSING_KEY_CONDITION",
      "Join query requires a key condition."
    );
  const i = P({
    model: e.model,
    where: n.remainingWhere,
    getFieldName: e.getFieldName
  });
  return await Q({
    documentClient: e.documentClient,
    tableName: t,
    indexName: n.indexName,
    keyConditionExpression: n.keyConditionExpression,
    filterExpression: i.filterExpression,
    expressionAttributeNames: {
      ...n.expressionAttributeNames,
      ...i.expressionAttributeNames
    },
    expressionAttributeValues: {
      ...n.expressionAttributeValues,
      ...i.expressionAttributeValues
    },
    limit: e.limit,
    explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
    operationStats: e.operationStats
  });
}, zt = async (e) => {
  const t = w({
    model: e.model,
    getDefaultModelName: e.getDefaultModelName,
    config: e.adapterConfig
  }), n = P({
    model: e.model,
    where: e.where,
    getFieldName: e.getFieldName
  });
  return await $e({
    documentClient: e.documentClient,
    tableName: t,
    filterExpression: n.filterExpression,
    expressionAttributeNames: n.expressionAttributeNames,
    expressionAttributeValues: n.expressionAttributeValues,
    limit: e.limit,
    maxPages: e.maxPages,
    explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
    operationStats: e.operationStats
  });
}, Yt = async (e) => {
  if (!e)
    throw new N(
      "MISSING_JOIN_EXECUTION_INPUT",
      "executeJoin requires explicit props."
    );
  const t = Ut({
    items: e.baseItems,
    field: e.join.on.from
  });
  if (t.length === 0)
    return e.baseItems.map((l) => ({
      ...l,
      [e.join.modelKey]: Qt(e.join.relation)
    }));
  const n = xt({
    joinField: e.join.on.to,
    model: e.join.model,
    baseValues: t,
    getFieldName: e.getFieldName,
    adapterConfig: e.adapterConfig
  }), i = jt({
    relation: e.join.relation,
    limit: e.join.limit
  }), r = await (async () => {
    if (n.kind === "batch-get") {
      const u = e.join.on.to;
      return X({
        documentClient: e.documentClient,
        tableName: w({
          model: e.join.model,
          getDefaultModelName: e.getDefaultModelName,
          config: e.adapterConfig
        }),
        keyField: u,
        keys: t,
        explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
        operationStats: e.operationStats
      });
    }
    if (n.kind === "query") {
      const u = Promise.resolve([]);
      return t.reduce(async (d, f) => {
        const b = await d, h = me({
          field: e.join.on.to,
          operator: "eq",
          value: f
        }), v = await Jt({
          documentClient: e.documentClient,
          adapterConfig: e.adapterConfig,
          model: e.join.model,
          where: h,
          limit: i,
          getFieldName: e.getFieldName,
          getDefaultModelName: e.getDefaultModelName,
          operationStats: e.operationStats
        });
        return [...b, ...v];
      }, u);
    }
    const l = me({
      field: e.join.on.to,
      operator: "in",
      value: t
    }), m = Gt({ adapterConfig: e.adapterConfig }), c = Bt({
      limit: i,
      baseValues: t
    });
    return zt({
      documentClient: e.documentClient,
      adapterConfig: e.adapterConfig,
      model: e.join.model,
      where: l,
      limit: c,
      maxPages: m,
      getFieldName: e.getFieldName,
      getDefaultModelName: e.getDefaultModelName,
      operationStats: e.operationStats
    });
  })(), s = Ht({
    items: r,
    field: e.join.on.to
  }), o = (l) => e.join.relation === "one-to-one" ? l[0] ?? null : l.slice(0, i);
  return e.baseItems.map((l) => {
    const m = l[e.join.on.from], c = Wt(s, m), u = o(c);
    return {
      ...l,
      [e.join.modelKey]: u
    };
  });
}, Xt = (e) => e.strategy.kind === "batch-get" ? !0 : e.requiresClientFilter, Zt = (e) => {
  if (e.serverSort)
    return e.serverSort.direction === "asc";
}, en = (e) => e.strategy.kind !== "query" ? e.keyConditionIndex : e.strategy.key === "gsi" ? e.strategy.indexName : e.keyConditionIndex, tn = (e) => e.serverSort ? e.items : Dt(e.items, { sortBy: e.sort }), nn = (e) => {
  if (e.adapterConfig.scanPageLimitMode === "unbounded")
    return Number.POSITIVE_INFINITY;
  if (e.adapterConfig.scanMaxPages === void 0)
    throw new N(
      "MISSING_SCAN_LIMIT",
      "Scan execution requires scanMaxPages."
    );
  return e.adapterConfig.scanMaxPages;
}, an = (e) => e.map((t) => ({
  field: t.field,
  operator: t.operator,
  value: t.value,
  connector: t.connector
})), rn = (e) => {
  const t = e.where.find(
    (n) => n.field === e.primaryKeyName && n.operator === "in"
  );
  return t ? Array.isArray(t.value) ? t.value : [] : [];
}, sn = async (e) => {
  const t = an(e.plan.base.where), n = w({
    model: e.plan.base.model,
    getDefaultModelName: e.getDefaultModelName,
    config: e.adapterConfig
  }), i = e.plan.execution.baseStrategy;
  if (i.kind === "batch-get") {
    const s = e.getFieldName({
      model: e.plan.base.model,
      field: "id"
    }), o = rn({
      where: e.plan.base.where,
      primaryKeyName: s
    });
    return o.length === 0 ? [] : X({
      documentClient: e.documentClient,
      tableName: n,
      keyField: s,
      keys: o,
      explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
      operationStats: e.operationStats
    });
  }
  if (i.kind === "multi-query") {
    const s = e.plan.base.where.find(
      (u) => u.field === i.field && u.operator === "in"
    );
    if (!s)
      return [];
    if (!Array.isArray(s.value))
      return [];
    const o = s.value, l = e.plan.execution.fetchLimit, m = e.plan.base.model;
    return (await Promise.all(
      o.map(async (u) => {
        const d = t.map((h) => h.field === i.field && h.operator === "in" ? {
          ...h,
          operator: "eq",
          value: u
        } : h), f = _({
          model: m,
          where: d,
          getFieldName: e.getFieldName,
          indexNameResolver: e.adapterConfig.indexNameResolver,
          indexKeySchemaResolver: e.adapterConfig.indexKeySchemaResolver
        });
        if (!f)
          return [];
        const b = P({
          model: m,
          where: f.remainingWhere,
          getFieldName: e.getFieldName
        });
        return await Q({
          documentClient: e.documentClient,
          tableName: n,
          indexName: f.indexName ?? i.indexName,
          keyConditionExpression: f.keyConditionExpression,
          filterExpression: b.filterExpression,
          expressionAttributeNames: {
            ...f.expressionAttributeNames,
            ...b.expressionAttributeNames
          },
          expressionAttributeValues: {
            ...f.expressionAttributeValues,
            ...b.expressionAttributeValues
          },
          limit: l,
          explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
          operationStats: e.operationStats
        });
      })
    )).flat();
  }
  if (i.kind === "query") {
    const s = _({
      model: e.plan.base.model,
      where: t,
      getFieldName: e.getFieldName,
      indexNameResolver: e.adapterConfig.indexNameResolver,
      indexKeySchemaResolver: e.adapterConfig.indexKeySchemaResolver
    });
    if (!s)
      throw new N(
        "MISSING_KEY_CONDITION",
        "Query strategy requires a key condition."
      );
    const o = P({
      model: e.plan.base.model,
      where: s.remainingWhere,
      getFieldName: e.getFieldName
    }), l = en({
      strategy: i,
      keyConditionIndex: s.indexName
    }), m = Zt({
      serverSort: e.plan.execution.serverSort
    });
    return await Q({
      documentClient: e.documentClient,
      tableName: n,
      indexName: l,
      keyConditionExpression: s.keyConditionExpression,
      filterExpression: o.filterExpression,
      expressionAttributeNames: {
        ...s.expressionAttributeNames,
        ...o.expressionAttributeNames
      },
      expressionAttributeValues: {
        ...s.expressionAttributeValues,
        ...o.expressionAttributeValues
      },
      limit: e.plan.execution.fetchLimit,
      scanIndexForward: m,
      explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
      operationStats: e.operationStats
    });
  }
  const a = P({
    model: e.plan.base.model,
    where: t,
    getFieldName: e.getFieldName
  }), r = nn({ adapterConfig: e.adapterConfig });
  return await $e({
    documentClient: e.documentClient,
    tableName: n,
    filterExpression: a.filterExpression,
    expressionAttributeNames: a.expressionAttributeNames,
    expressionAttributeValues: a.expressionAttributeValues,
    limit: e.plan.execution.fetchLimit,
    maxPages: r,
    explainDynamoOperations: e.adapterConfig.explainDynamoOperations,
    operationStats: e.operationStats
  });
}, on = (e) => {
  const t = e.offset ?? 0;
  return e.limit === void 0 ? e.items.slice(t) : e.items.slice(t, t + e.limit);
}, M = (e) => {
  if (!e)
    throw new N(
      "MISSING_EXECUTOR_INPUT",
      "createQueryPlanExecutor requires explicit props."
    );
  return async (t, n) => {
    const i = await sn({
      plan: t,
      documentClient: e.documentClient,
      adapterConfig: e.adapterConfig,
      getFieldName: e.getFieldName,
      getDefaultModelName: e.getDefaultModelName,
      operationStats: n?.operationStats
    }), a = Xt({
      strategy: t.execution.baseStrategy,
      requiresClientFilter: t.execution.requiresClientFilter
    }), r = Et({
      items: i,
      where: t.base.where,
      requiresClientFilter: a
    }), s = tn({
      items: r,
      serverSort: t.execution.serverSort,
      sort: t.base.sort
    }), o = on({
      items: s,
      offset: t.base.offset,
      limit: t.base.limit
    }), m = await t.joins.reduce(
      async (d, f) => {
        const b = await d;
        return Yt({
          baseItems: b,
          join: f,
          documentClient: e.documentClient,
          adapterConfig: e.adapterConfig,
          getFieldName: e.getFieldName,
          getDefaultModelName: e.getDefaultModelName,
          operationStats: n?.operationStats
        });
      },
      Promise.resolve(o)
    ), c = t.joins.map((d) => d.modelKey);
    return Pt({
      items: m,
      model: t.base.model,
      select: t.base.select,
      joinKeys: c,
      getFieldName: e.getFieldName
    });
  };
}, ln = () => ">=1", un = (e) => e === void 0 ? "unknown" : Number.isFinite(e) ? `<=${e}` : "unbounded", cn = (e) => typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null ? JSON.stringify(e) : Array.isArray(e) ? `[${e.map((t) => JSON.stringify(t)).join(", ")}]` : "…", dn = (e) => `${e.connector} ${e.field} ${e.operator} ${cn(e.value)}`, B = (e) => e === void 0 ? "∞" : String(e), fe = (e) => e.kind === "query" ? e.key === "pk" ? "query(pk)" : `query(gsi:${e.indexName ?? "?"})` : e.kind === "multi-query" ? `multi-query(gsi:${e.indexName})` : e.kind === "batch-get" ? "batch-get(pk)" : "scan", R = (e, t) => {
  const n = "  ".repeat(t);
  return e.map((i) => `${n}${i}`);
}, ye = (e) => {
  const t = e.where.find((n) => n.operator !== "in" || !Array.isArray(n.value) ? !1 : e.field === void 0 ? !0 : n.field === e.field);
  if (t && Array.isArray(t.value))
    return t.value.length;
}, mn = (e) => {
  const t = e.plan.execution.baseStrategy;
  if (t.kind === "scan")
    return e.adapterConfig.scanPageLimitMode === "unbounded" ? "ScanCommand: unbounded" : `ScanCommand: ${un(e.adapterConfig.scanMaxPages)}`;
  if (t.kind === "query")
    return `QueryCommand: ${ln()}`;
  if (t.kind === "multi-query") {
    const n = ye({
      where: e.plan.base.where,
      field: t.field
    });
    return n === void 0 ? "QueryCommand: unknown" : `QueryCommand: =${n}`;
  }
  if (t.kind === "batch-get") {
    const n = ye({ where: e.plan.base.where });
    return n === void 0 ? "BatchGetCommand: unknown" : `BatchGetCommand: =${Math.ceil(n / 100)} (chunks=${Math.ceil(n / 100)})`;
  }
  return "unknown";
}, fn = (e) => {
  const t = e.plan, n = w({
    model: t.base.model,
    getDefaultModelName: e.getDefaultModelName,
    config: e.adapterConfig
  }), i = [], a = fe(t.execution.baseStrategy).toUpperCase(), r = B(t.execution.fetchLimit), o = t.execution.baseStrategy.kind !== "scan" ? "n/a" : B(e.adapterConfig.scanMaxPages);
  i.push(
    `-> ${a} table=${n} fetchLimit=${r} scanMaxPages=${o} scanPageLimitMode=${e.adapterConfig.scanPageLimitMode}`
  ), i.push(`   est: ${mn({ plan: t, adapterConfig: e.adapterConfig })}`), (t.constraints.hasOrConnector || t.constraints.hasClientOnlyOperator) && i.push(
    `-> FILTER (client) or=${t.constraints.hasOrConnector} clientOnly=${t.constraints.hasClientOnlyOperator}`
  ), t.execution.requiresClientSort && i.push("-> SORT (client)"), (t.base.offset !== void 0 || t.base.limit !== void 0) && i.push(
    `-> LIMIT offset=${t.base.offset ?? 0} limit=${B(t.base.limit)}`
  );
  const l = t.joins.reduce((m, c) => {
    const u = w({
      model: c.model,
      getDefaultModelName: e.getDefaultModelName,
      config: e.adapterConfig
    }), d = fe(c.strategy), f = [];
    return f.push(
      `-> JOIN ${c.modelKey} relation=${c.relation} on ${c.on.from} = ${c.on.to} strategy=${d} table=${u}`
    ), d === "query(pk)" && f.push("   note: uses BATCH-GET when >1 distinct key"), [...f, ...R(m, 1)];
  }, i);
  return t.base.select && t.base.select.length > 0 ? [
    `-> PROJECT (${t.base.select.join(", ")})`,
    ...R(l, 1)
  ] : ["-> PROJECT (*)", ...R(l, 1)];
}, Z = (e) => {
  const t = [];
  t.push("EXPLAIN DynamoDBAdapter"), t.push(`QUERY model=${e.plan.base.model}`);
  const n = e.plan.base.where.map((i) => dn(i));
  if (n.length > 0) {
    t.push("WHERE");
    for (const i of n)
      t.push(`  ${i}`);
  } else
    t.push("WHERE (none)");
  return t.push("PLAN"), t.push(...R(fn(e), 1)), t.join(`
`);
}, G = (e, t) => {
  const n = e[t.tableName];
  if (n)
    return n;
  const i = t.makeInitial();
  return e[t.tableName] = i, i;
}, ee = () => {
  const e = {
    totals: {
      scanCommands: 0,
      queryCommands: 0,
      batchGetCommands: 0
    },
    scans: {},
    queries: {},
    batchGets: {}
  };
  return {
    recordScan: (t) => {
      e.totals.scanCommands += 1;
      const n = G(e.scans, {
        tableName: t.tableName,
        makeInitial: () => ({ commands: 0, items: 0 })
      });
      n.commands += 1, n.items += t.items;
    },
    recordQuery: (t) => {
      e.totals.queryCommands += 1;
      const n = G(e.queries, {
        tableName: t.tableName,
        makeInitial: () => ({ commands: 0, items: 0 })
      });
      n.commands += 1, n.items += t.items;
    },
    recordBatchGet: (t) => {
      e.totals.batchGetCommands += 1;
      const n = G(e.batchGets, {
        tableName: t.tableName,
        makeInitial: () => ({ commands: 0, keys: 0, retries: 0, items: 0 })
      });
      n.commands += 1, n.keys += t.keys, n.items += t.items, t.isRetry && (n.retries += 1);
    },
    snapshot: () => e
  };
}, U = (e) => Object.keys(e).sort((t, n) => t.localeCompare(n)), te = (e) => {
  const t = [];
  t.push("ACTUAL"), t.push(
    `  commands: ScanCommand=${e.totals.scanCommands} QueryCommand=${e.totals.queryCommands} BatchGetCommand=${e.totals.batchGetCommands}`
  );
  for (const n of U(e.scans)) {
    const i = e.scans[n];
    t.push(
      `  SCAN table=${n} commands=${i.commands} items=${i.items}`
    );
  }
  for (const n of U(e.queries)) {
    const i = e.queries[n];
    t.push(
      `  QUERY table=${n} commands=${i.commands} items=${i.items}`
    );
  }
  for (const n of U(e.batchGets)) {
    const i = e.batchGets[n];
    t.push(
      `  BATCH-GET table=${n} commands=${i.commands} keys=${i.keys} retries=${i.retries} items=${i.items}`
    );
  }
  return t.join(`
`);
}, yn = (e, t) => {
  const { documentClient: n } = e, { adapterConfig: i, getFieldName: a, getDefaultModelName: r } = t, s = () => {
    if (i.scanPageLimitMode === "unbounded")
      return Number.POSITIVE_INFINITY;
    if (i.scanMaxPages === void 0)
      throw new N(
        "MISSING_SCAN_LIMIT",
        "Count scan requires scanMaxPages."
      );
    return i.scanMaxPages;
  };
  return async ({
    model: o,
    where: l
  }) => {
    const c = (() => {
      if (i.explainQueryPlans)
        return ee();
    })(), u = (g) => (i.explainQueryPlans && c && console.log(te(c.snapshot())), g), d = O({
      model: o,
      where: l,
      select: void 0,
      sortBy: void 0,
      limit: void 0,
      offset: void 0,
      join: void 0,
      getFieldName: a,
      adapterConfig: i
    });
    if (i.explainQueryPlans && console.log(
      Z({
        plan: d,
        adapterConfig: i,
        getDefaultModelName: r
      })
    ), d.execution.requiresClientFilter) {
      const x = await M({
        documentClient: n,
        adapterConfig: i,
        getFieldName: a,
        getDefaultModelName: r
      })(d, { operationStats: c });
      return u(x.length);
    }
    if (d.execution.baseStrategy.kind === "batch-get") {
      const x = await M({
        documentClient: n,
        adapterConfig: i,
        getFieldName: a,
        getDefaultModelName: r
      })(d, { operationStats: c });
      return u(x.length);
    }
    const f = w({
      model: o,
      getDefaultModelName: r,
      config: i
    }), b = d.base.where.map((g) => ({
      field: g.field,
      operator: g.operator,
      value: g.value,
      connector: g.connector
    }));
    if (d.execution.baseStrategy.kind === "query") {
      const g = _({
        model: o,
        where: b,
        getFieldName: a,
        indexNameResolver: i.indexNameResolver,
        indexKeySchemaResolver: i.indexKeySchemaResolver
      });
      if (!g)
        throw new N(
          "MISSING_KEY_CONDITION",
          "Count query requires a key condition."
        );
      const x = P({
        model: o,
        where: g.remainingWhere,
        getFieldName: a
      }), S = await Vt({
        documentClient: n,
        tableName: f,
        indexName: g.indexName,
        keyConditionExpression: g.keyConditionExpression,
        filterExpression: x.filterExpression,
        expressionAttributeNames: {
          ...g.expressionAttributeNames,
          ...x.expressionAttributeNames
        },
        expressionAttributeValues: {
          ...g.expressionAttributeValues,
          ...x.expressionAttributeValues
        },
        explainDynamoOperations: i.explainDynamoOperations,
        operationStats: c
      });
      return u(S);
    }
    const h = P({
      model: o,
      where: b,
      getFieldName: a
    }), v = s(), T = await Rt({
      documentClient: n,
      tableName: f,
      filterExpression: h.filterExpression,
      expressionAttributeNames: h.expressionAttributeNames,
      expressionAttributeValues: h.expressionAttributeValues,
      maxPages: v,
      explainDynamoOperations: i.explainDynamoOperations,
      operationStats: c
    });
    return u(T);
  };
}, bn = () => ({
  operations: []
}), ne = (e, t) => {
  if (e.operations.length >= 25)
    throw new N(
      "TRANSACTION_LIMIT",
      "DynamoDB transactions are limited to 25 operations."
    );
  e.operations.push(t);
}, Nn = (e) => e.kind === "put" ? {
  Put: {
    TableName: e.tableName,
    Item: e.item
  }
} : e.kind === "update" ? {
  Update: {
    TableName: e.tableName,
    Key: e.key,
    UpdateExpression: e.updateExpression,
    ExpressionAttributeNames: e.expressionAttributeNames,
    ExpressionAttributeValues: e.expressionAttributeValues
  }
} : {
  Delete: {
    TableName: e.tableName,
    Key: e.key
  }
}, xn = async (e) => {
  const { documentClient: t, state: n } = e;
  if (n.operations.length === 0)
    return;
  const i = n.operations.map(
    (a) => Nn(a)
  );
  await t.send(
    new He({
      TransactItems: i
    })
  );
}, gn = (e, t) => {
  const { documentClient: n } = e, { adapterConfig: i, getDefaultModelName: a, transactionState: r } = t, s = (o) => w({
    model: o,
    getDefaultModelName: a,
    config: i
  });
  return async ({
    model: o,
    data: l
  }) => {
    const m = s(o);
    return r ? (ne(r, {
      kind: "put",
      tableName: m,
      item: l
    }), l) : (await n.send(
      new Qe({
        TableName: m,
        Item: l
      })
    ), l);
  };
}, Ve = (e) => {
  const { item: t, keyField: n } = e;
  if (!(n in t))
    throw new N(
      "MISSING_PRIMARY_KEY",
      `Item is missing primary key field "${n}".`
    );
  return { [n]: t[n] };
}, Re = (e, t) => {
  const { documentClient: n } = e, {
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r,
    transactionState: s
  } = t, o = M({
    documentClient: n,
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r
  }), l = (c) => w({
    model: c,
    getDefaultModelName: r,
    config: i
  }), m = (c) => a({ model: c, field: "id" });
  return async ({ model: c, where: u, limit: d }) => {
    const f = l(c), b = O({
      model: c,
      where: u,
      select: void 0,
      sortBy: void 0,
      limit: d,
      offset: void 0,
      join: void 0,
      getFieldName: a,
      adapterConfig: i
    }), h = await o(b);
    if (h.length === 0)
      return 0;
    const v = m(c), T = { deleted: 0 };
    for (const g of h) {
      const x = Ve({
        item: g,
        keyField: v
      });
      s ? ne(s, {
        kind: "delete",
        tableName: f,
        key: x
      }) : await n.send(
        new We({
          TableName: f,
          Key: x
        })
      ), T.deleted += 1;
    }
    return T.deleted;
  };
}, hn = (e, t) => {
  const n = Re(e, t);
  return async ({ model: i, where: a }) => n({ model: i, where: a });
}, Sn = (e, t) => {
  const n = Re(e, t);
  return async ({
    model: i,
    where: a
  }) => {
    await n({ model: i, where: a, limit: 1 });
  };
}, vn = (e, t) => {
  const { documentClient: n } = e, {
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r
  } = t, s = M({
    documentClient: n,
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r
  });
  return async ({
    model: o,
    where: l,
    limit: m,
    sortBy: c,
    offset: u,
    join: d
  }) => {
    const f = O({
      model: o,
      where: l,
      select: void 0,
      sortBy: c,
      limit: m,
      offset: u,
      join: d,
      getFieldName: a,
      adapterConfig: i
    }), h = (() => {
      if (i.explainQueryPlans)
        return ee();
    })();
    i.explainQueryPlans && console.log(
      Z({
        plan: f,
        adapterConfig: i,
        getDefaultModelName: r
      })
    );
    const v = await s(f, { operationStats: h });
    return i.explainQueryPlans && h && console.log(te(h.snapshot())), v;
  };
}, An = (e, t) => {
  const n = vn(e, t);
  return async (i) => await n(i);
}, Cn = (e) => {
  const { transactionState: t, tableName: n, where: i } = e, a = t.operations.filter(
    (o) => o.kind === "put" && o.tableName === n
  ).map((o) => o.item);
  if (a.length === 0)
    return { found: !1 };
  const r = Pe({ where: i }), s = Fe({
    items: a,
    where: r
  });
  return s.length === 0 ? { found: !1 } : { found: !0, item: s[s.length - 1] };
}, Tn = (e, t) => {
  const n = M({
    documentClient: e.documentClient,
    adapterConfig: t.adapterConfig,
    getFieldName: t.getFieldName,
    getDefaultModelName: t.getDefaultModelName
  });
  return async ({
    model: i,
    where: a,
    select: r,
    join: s
  }) => {
    if (t.transactionState) {
      const u = w({
        model: i,
        getDefaultModelName: t.getDefaultModelName,
        config: t.adapterConfig
      }), d = Cn({
        transactionState: t.transactionState,
        tableName: u,
        where: a
      });
      if (d.found)
        return d.item;
    }
    if (t.primaryKeyLoader && s === void 0 && r === void 0 && a.length === 1) {
      const u = a[0], d = u.operator ?? "eq", f = (u.connector ?? "AND").toUpperCase(), b = t.getFieldName({ model: i, field: "id" });
      if (d === "eq" && f === "AND" && u.field === b) {
        const h = u.value;
        return h === void 0 ? null : await t.primaryKeyLoader.load({ model: i, key: h }) ?? null;
      }
    }
    const o = O({
      model: i,
      where: a,
      select: r,
      sortBy: void 0,
      limit: 1,
      offset: 0,
      join: s,
      getFieldName: t.getFieldName,
      adapterConfig: t.adapterConfig
    }), m = (() => {
      if (t.adapterConfig.explainQueryPlans)
        return ee();
    })();
    t.adapterConfig.explainQueryPlans && console.log(
      Z({
        plan: o,
        adapterConfig: t.adapterConfig,
        getDefaultModelName: t.getDefaultModelName
      })
    );
    const c = await n(o, { operationStats: m });
    return t.adapterConfig.explainQueryPlans && m && console.log(te(m.snapshot())), c.length === 0 ? null : c[0];
  };
}, be = (e) => e !== null && typeof e == "object" && !Array.isArray(e), W = (e, t, n) => {
  if (Object.is(t, n))
    return [];
  if (typeof t != typeof n)
    return [{ path: e, prev: t, next: n }];
  if (Array.isArray(t) && Array.isArray(n)) {
    const i = Math.max(t.length, n.length);
    return Array.from({ length: i }, (a, r) => {
      const s = t[r], o = n[r];
      return W([...e, r], s, o);
    }).flat();
  }
  if (be(t) && be(n)) {
    const i = /* @__PURE__ */ new Set([...Object.keys(t), ...Object.keys(n)]);
    return Array.from(i).flatMap(
      (a) => W([...e, a], t[a], n[a])
    );
  }
  return [{ path: e, prev: t, next: n }];
}, Ne = (e) => {
  const t = /* @__PURE__ */ new Map(), n = { value: 0 };
  return (i) => {
    const a = t.get(i);
    if (a)
      return a;
    const r = `${e}${n.value}`;
    return n.value += 1, t.set(i, r), r;
  };
}, In = (e, t) => typeof e < "u" && typeof t > "u", wn = (e, t) => typeof e == "number" && typeof t == "number", En = (e, t) => typeof e != typeof t, pn = (e, t) => typeof e == typeof t, xe = (e) => {
  if (typeof e == "string")
    return e;
  try {
    return JSON.stringify(e);
  } catch {
    throw new N(
      "INVALID_UPDATE",
      "Failed to serialize update value."
    );
  }
}, kn = (e) => {
  if (Object.is(e.prev, e.next))
    return {
      kind: "noop",
      expression: "",
      attributeNames: {},
      attributeValues: {}
    };
  const t = e.path.filter(
    (o) => typeof o == "string"
  ), n = t.map(
    (o) => e.makeNameKey(o)
  ), i = (o) => o === "" ? "" : ".", a = e.path.reduce((o, l) => {
    if (typeof l == "number")
      return `${o}[${l}]`;
    const m = i(o);
    return `${o}${m}#${e.makeNameKey(l)}`;
  }, ""), r = n.map((o, l) => [
    `#${o}`,
    t[l].toString()
  ]), s = Object.fromEntries(r);
  if (In(e.prev, e.next))
    return {
      kind: "remove",
      expression: a,
      attributeNames: s,
      attributeValues: {}
    };
  if (wn(e.prev, e.next)) {
    const o = e.next - e.prev, l = e.makeValueKey(xe(o));
    return {
      kind: "add",
      expression: `${a} :${l}`,
      attributeNames: s,
      attributeValues: {
        [`:${l}`]: o
      }
    };
  }
  if (pn(e.prev, e.next) || En(e.prev, e.next)) {
    const o = e.makeValueKey(xe(e.next));
    return {
      kind: "set",
      expression: `${a} = :${o}`,
      attributeNames: s,
      attributeValues: {
        [`:${o}`]: e.next
      }
    };
  }
  return {
    kind: "noop",
    expression: "",
    attributeNames: {},
    attributeValues: {}
  };
}, Dn = (e) => {
  const t = e.reduce(
    (i, a) => {
      const r = i[a.kind] ?? [];
      return i[a.kind] = [...r, a], i;
    },
    {}
  ), n = Object.entries(t).reduce(
    (i, [a, r]) => {
      if (a === "noop")
        return i;
      const s = r.map((o) => o.expression).join(",");
      return {
        updateExpression: [...i.updateExpression, `${a.toUpperCase()} ${s}`],
        attributeNames: r.reduce(
          (o, l) => ({ ...o, ...l.attributeNames }),
          i.attributeNames
        ),
        attributeValues: r.reduce(
          (o, l) => ({ ...o, ...l.attributeValues }),
          i.attributeValues
        )
      };
    },
    {
      updateExpression: [],
      attributeNames: {},
      attributeValues: {}
    }
  );
  return {
    updateExpression: n.updateExpression.join(" "),
    attributeNames: n.attributeNames,
    attributeValues: n.attributeValues
  };
}, Pn = (e) => {
  if (!e)
    throw new N(
      "INVALID_UPDATE",
      "Patch update requires explicit prev/next."
    );
  const t = W([], e.prev, e.next);
  if (t.length === 0)
    throw new N(
      "INVALID_UPDATE",
      "Update payload must include at least one defined value."
    );
  const n = Ne("a"), i = Ne("v"), a = t.map(
    (s) => kn({
      ...s,
      makeNameKey: n,
      makeValueKey: i
    })
  ), r = Dn(a);
  if (!r.updateExpression)
    throw new N(
      "INVALID_UPDATE",
      "Update payload must include at least one defined value."
    );
  return {
    updateExpression: r.updateExpression,
    expressionAttributeNames: r.attributeNames,
    expressionAttributeValues: r.attributeValues
  };
}, Kn = (e, t) => Object.entries(t).reduce(
  (n, [i, a]) => ({ ...n, [i]: a }),
  { ...e }
), Mn = (e) => Object.entries(e).reduce(
  (n, [i, a]) => a === void 0 ? n : { ...n, [i]: a },
  {}
), Fn = (e) => e ? { ReturnValues: "ALL_NEW" } : {}, _e = (e, t) => {
  const { documentClient: n } = e, {
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r,
    transactionState: s
  } = t, o = M({
    documentClient: n,
    adapterConfig: i,
    getFieldName: a,
    getDefaultModelName: r
  }), l = (c) => w({
    model: c,
    getDefaultModelName: r,
    config: i
  }), m = (c) => a({ model: c, field: "id" });
  return async ({
    model: c,
    where: u,
    update: d,
    limit: f,
    returnUpdatedItems: b
  }) => {
    const h = l(c), v = O({
      model: c,
      where: u,
      select: void 0,
      sortBy: void 0,
      limit: f,
      offset: void 0,
      join: void 0,
      getFieldName: a,
      adapterConfig: i
    }), T = await o(v);
    if (T.length === 0)
      return { updatedCount: 0, updatedItems: [] };
    const g = m(c), x = {
      updatedCount: 0,
      updatedItems: []
    };
    for (const S of T) {
      const A = Kn(
        S,
        d
      ), I = Pn({
        prev: S,
        next: A
      }), D = Ve({
        item: S,
        keyField: g
      });
      if (s)
        ne(s, {
          kind: "update",
          tableName: h,
          key: D,
          updateExpression: I.updateExpression,
          expressionAttributeNames: I.expressionAttributeNames,
          expressionAttributeValues: I.expressionAttributeValues
        }), b && x.updatedItems.push(
          Mn(A)
        );
      else {
        const E = {
          TableName: h,
          Key: D,
          UpdateExpression: I.updateExpression,
          ExpressionAttributeNames: I.expressionAttributeNames,
          ExpressionAttributeValues: I.expressionAttributeValues,
          ...Fn(b)
        }, F = await n.send(
          new Je(E)
        );
        b && F.Attributes && x.updatedItems.push(
          F.Attributes
        );
      }
      x.updatedCount += 1;
    }
    return x;
  };
}, On = (e, t) => {
  const n = _e(e, t);
  return async ({
    model: i,
    where: a,
    update: r
  }) => (await n({
    model: i,
    where: a,
    update: r,
    returnUpdatedItems: !1
  })).updatedCount;
}, $n = (e, t) => {
  const n = _e(e, t);
  return async ({
    model: i,
    where: a,
    update: r
  }) => {
    const s = await n({
      model: i,
      where: a,
      update: r,
      limit: 1,
      returnUpdatedItems: !0
    });
    return s.updatedItems.length === 0 ? null : s.updatedItems[0];
  };
}, ge = (e) => String(e), Vn = (e) => `${e.tableName}:${e.keyField}`, Rn = (e) => {
  if (!e)
    throw new N(
      "MISSING_EXECUTOR_INPUT",
      "createPrimaryKeyBatchLoader requires explicit props."
    );
  const t = /* @__PURE__ */ new Map(), n = (r) => {
    const s = w({
      model: r,
      getDefaultModelName: e.getDefaultModelName,
      config: e.adapterConfig
    }), o = e.getFieldName({ model: r, field: "id" }), l = Vn({ tableName: s, keyField: o }), m = t.get(l);
    if (m)
      return m;
    const c = {
      model: r,
      keyField: o,
      tableName: s,
      scheduled: !1,
      pendingByToken: /* @__PURE__ */ new Map()
    };
    return t.set(l, c), c;
  }, i = async (r) => {
    if (r.pendingByToken.size === 0) {
      r.scheduled = !1;
      return;
    }
    const s = new Map(r.pendingByToken);
    r.pendingByToken.clear(), r.scheduled = !1;
    const o = Array.from(s.values()).map((l) => l.key);
    if (e.adapterConfig.explainQueryPlans) {
      const l = Math.ceil(o.length / 100);
      console.log(
        [
          "EXPLAIN DynamoDBAdapter",
          `BATCH-GET model=${r.model} table=${r.tableName} key=${r.keyField}`,
          "PLAN",
          `  -> BATCH-GET keys=${o.length} chunks=${l} estimatedCommands=${l}`
        ].join(`
`)
      );
    }
    try {
      const l = await X({
        documentClient: e.documentClient,
        tableName: r.tableName,
        keyField: r.keyField,
        keys: o,
        explainDynamoOperations: e.adapterConfig.explainDynamoOperations
      }), m = /* @__PURE__ */ new Map();
      for (const c of l) {
        const u = c[r.keyField];
        u !== void 0 && m.set(ge(u), c);
      }
      for (const [c, u] of s.entries()) {
        const d = m.get(c) ?? null;
        for (const f of u.pending)
          f.resolve(d);
      }
    } catch (l) {
      for (const m of s.values())
        for (const c of m.pending)
          c.reject(l);
    }
  }, a = (r) => {
    r.scheduled || (r.scheduled = !0, queueMicrotask(() => {
      i(r);
    }));
  };
  return {
    load: async (r) => {
      const s = n(r.model), o = ge(r.key);
      return new Promise((l, m) => {
        const c = s.pendingByToken.get(o);
        if (c) {
          c.pending.push({ resolve: l, reject: m });
          return;
        }
        s.pendingByToken.set(o, {
          key: r.key,
          pending: [{ resolve: l, reject: m }]
        }), a(s);
      });
    }
  };
}, _n = (e) => {
  if (!e)
    throw new N("MISSING_CLIENT", "DynamoDB adapter requires a DynamoDBDocumentClient instance.");
  return e;
}, he = (e) => {
  const { documentClient: t, adapterConfig: n, transactionState: i } = e;
  return ({ getFieldName: a, getDefaultModelName: r }) => {
    const s = { documentClient: t }, o = Rn({
      documentClient: t,
      adapterConfig: n,
      getFieldName: a,
      getDefaultModelName: r
    }), l = {
      adapterConfig: n,
      getFieldName: a,
      getDefaultModelName: r
    }, m = l, c = {
      ...l,
      transactionState: i
    }, u = {
      ...l,
      transactionState: i
    };
    return {
      create: gn(s, {
        adapterConfig: n,
        getDefaultModelName: r,
        transactionState: i
      }),
      findOne: Tn(s, {
        ...l,
        primaryKeyLoader: o,
        transactionState: i
      }),
      findMany: An(s, l),
      count: yn(s, m),
      update: $n(s, c),
      updateMany: On(s, c),
      delete: Sn(s, u),
      deleteMany: hn(s, u),
      createSchema: async (f) => ({
        code: st({
          tables: f.tables,
          file: f.file,
          tableNamePrefix: n.tableNamePrefix
        }),
        path: f.file ?? "dynamodb-tables.ts",
        overwrite: !0
      })
    };
  };
}, ei = (e) => {
  if (!e.indexNameResolver)
    throw new N(
      "MISSING_INDEX_RESOLVER",
      "DynamoDB adapter requires indexNameResolver."
    );
  const t = {
    documentClient: e.documentClient,
    debugLogs: e.debugLogs,
    usePlural: e.usePlural ?? !1,
    tableNamePrefix: e.tableNamePrefix,
    tableNameResolver: e.tableNameResolver,
    scanMaxPages: e.scanMaxPages,
    scanPageLimitMode: e.scanPageLimitMode ?? "throw",
    explainQueryPlans: e.explainQueryPlans ?? !1,
    explainDynamoOperations: e.explainDynamoOperations ?? !1,
    indexNameResolver: e.indexNameResolver,
    indexKeySchemaResolver: e.indexKeySchemaResolver,
    transaction: e.transaction ?? !1
  }, n = _n(t.documentClient), i = { value: null }, a = {
    config: {
      adapterId: "dynamodb-adapter",
      adapterName: "DynamoDB Adapter",
      usePlural: t.usePlural,
      debugLogs: t.debugLogs ?? !1,
      supportsArrays: !0,
      supportsJSON: !0,
      supportsUUIDs: !1,
      supportsNumericIds: !1,
      supportsDates: !1,
      customIdGenerator: e.customIdGenerator ?? (() => Ge()),
      disableIdGeneration: e.disableIdGeneration,
      mapKeysTransformInput: e.mapKeysTransformInput,
      mapKeysTransformOutput: e.mapKeysTransformOutput,
      customTransformInput: e.customTransformInput,
      customTransformOutput: e.customTransformOutput,
      transaction: !1
    },
    adapter: he({
      documentClient: n,
      adapterConfig: t
    })
  };
  t.transaction && (a.config.transaction = async (s) => {
    const o = i.value;
    if (!o)
      throw new N("MISSING_CLIENT", "DynamoDB adapter options are not initialized.");
    const l = bn(), m = se({
      config: { ...a.config, transaction: !1 },
      adapter: he({
        documentClient: n,
        adapterConfig: t,
        transactionState: l
      })
    })(o), c = await s(m);
    return await xn({ documentClient: n, state: l }), c;
  });
  const r = se(a);
  return (s) => (i.value = s, r(s));
}, H = async (e) => {
  e <= 0 || await new Promise((t) => {
    setTimeout(() => t(), e);
  });
}, qn = async (e) => {
  const t = [], n = { lastEvaluatedTableName: void 0 };
  for (; ; ) {
    const i = await e.send(
      new Ze({
        ExclusiveStartTableName: n.lastEvaluatedTableName
      })
    );
    if (t.push(...i.TableNames ?? []), n.lastEvaluatedTableName = i.LastEvaluatedTableName, !n.lastEvaluatedTableName)
      break;
  }
  return t;
}, J = async (e, t) => {
  const n = await e.send(new et({ TableName: t }));
  if (!n.Table)
    throw new N(
      "MISSING_TABLE_SCHEMA",
      `DescribeTable did not return a Table for ${t}.`
    );
  return n.Table;
}, Se = (e) => (e ?? []).map((n) => ({
  attributeName: n.AttributeName ?? "",
  keyType: n.KeyType ?? ""
})).filter((n) => n.attributeName.length > 0 && n.keyType.length > 0), ve = (e) => {
  const t = e?.ProjectionType ?? "", n = [...e?.NonKeyAttributes ?? []].sort(
    (i, a) => i.localeCompare(a)
  );
  return { projectionType: t, nonKeyAttributes: n };
}, Ae = (e) => ({
  read: e?.ReadCapacityUnits,
  write: e?.WriteCapacityUnits
}), Ln = (e) => {
  const t = Se(e.existing.KeySchema), n = Se(e.desired.KeySchema);
  if (t.length !== n.length)
    return !1;
  for (const [o, l] of t.entries()) {
    const m = n[o];
    if (!m || l.attributeName !== m.attributeName || l.keyType !== m.keyType)
      return !1;
  }
  const i = ve(e.existing.Projection), a = ve(e.desired.Projection);
  if (i.projectionType !== a.projectionType || i.nonKeyAttributes.length !== a.nonKeyAttributes.length)
    return !1;
  for (const [o, l] of i.nonKeyAttributes.entries())
    if (l !== a.nonKeyAttributes[o])
      return !1;
  const r = Ae(e.existing.ProvisionedThroughput), s = Ae(e.desired.ProvisionedThroughput);
  return !(r.read !== s.read || r.write !== s.write);
}, jn = (e) => (e.GlobalSecondaryIndexes ?? []).reduce((n, i) => (n.set(i.IndexName ?? "", i), n), /* @__PURE__ */ new Map()), qe = (e) => (e.attributeDefinitions ?? []).reduce((n, i) => (i.AttributeName && n.set(i.AttributeName, i), n), /* @__PURE__ */ new Map()), Bn = (e) => (e.KeySchema ?? []).map((n) => n.AttributeName).filter((n) => typeof n == "string" && n.length > 0), Gn = (e) => {
  const t = qe({
    attributeDefinitions: e.desiredTableAttributeDefinitions
  }), n = [], i = Bn(e.index);
  for (const a of i) {
    const r = e.existing.get(a);
    if (r) {
      const o = t.get(a);
      if (o && o.AttributeType && r.AttributeType && o.AttributeType !== r.AttributeType)
        throw new N(
          "ATTRIBUTE_DEFINITION_MISMATCH",
          `Attribute type mismatch for ${a}: existing=${r.AttributeType} desired=${o.AttributeType}`
        );
      continue;
    }
    const s = t.get(a);
    if (!s)
      throw new N(
        "MISSING_ATTRIBUTE_DEFINITION",
        `Missing AttributeDefinition for ${a} required by GSI ${e.index.IndexName ?? "(unknown)"}.`
      );
    n.push(s);
  }
  return n;
}, Le = async (e) => {
  const t = Date.now(), n = Math.max(0, (e.wait.maxWaitTime ?? 60) * 1e3), i = Math.max(0, (e.wait.minDelay ?? 2) * 1e3), a = e.presentGsiNames ?? [], r = e.absentGsiNames ?? [];
  for (; ; ) {
    const s = await J(e.client, e.tableName), o = s.TableStatus ?? "", m = (s.GlobalSecondaryIndexes ?? []).reduce((d, f) => {
      const b = f.IndexName ?? "";
      return b.length === 0 || d.set(b, f.IndexStatus ?? ""), d;
    }, /* @__PURE__ */ new Map()), c = a.every((d) => m.get(d) === "ACTIVE"), u = r.every((d) => !m.has(d));
    if (o !== "ACTIVE") {
      if (Date.now() - t > n)
        throw new N(
          "TABLE_WAIT_TIMEOUT",
          `Timed out waiting for table ${e.tableName} to become ready.`
        );
      await H(i);
      continue;
    }
    if (!c) {
      if (Date.now() - t > n)
        throw new N(
          "TABLE_WAIT_TIMEOUT",
          `Timed out waiting for table ${e.tableName} to become ready.`
        );
      await H(i);
      continue;
    }
    if (!u) {
      if (Date.now() - t > n)
        throw new N(
          "TABLE_WAIT_TIMEOUT",
          `Timed out waiting for table ${e.tableName} to become ready.`
        );
      await H(i);
      continue;
    }
    return;
  }
}, Un = async (e) => {
  await e.client.send(
    new we({
      TableName: e.tableName,
      GlobalSecondaryIndexUpdates: [
        {
          Delete: { IndexName: e.indexName }
        }
      ]
    })
  ), await Le({
    client: e.client,
    tableName: e.tableName,
    wait: e.wait,
    absentGsiNames: [e.indexName]
  });
}, Ce = async (e) => {
  const t = qe({
    attributeDefinitions: e.existingAttributeDefinitions
  }), n = Gn({
    existing: t,
    desiredTableAttributeDefinitions: e.desiredTableAttributeDefinitions,
    index: e.index
  });
  await e.client.send(
    new we({
      TableName: e.tableName,
      AttributeDefinitions: n.length > 0 ? n : void 0,
      GlobalSecondaryIndexUpdates: [
        {
          Create: {
            IndexName: e.index.IndexName,
            KeySchema: e.index.KeySchema,
            Projection: e.index.Projection,
            ProvisionedThroughput: e.index.ProvisionedThroughput
          }
        }
      ]
    })
  ), await Le({
    client: e.client,
    tableName: e.tableName,
    wait: e.wait,
    presentGsiNames: [e.index.IndexName ?? ""].filter((i) => i.length > 0)
  });
}, Hn = async (e) => {
  if (!e.client)
    throw new N(
      "MISSING_CLIENT",
      "DynamoDB applyTableSchemas requires a DynamoDBClient instance."
    );
  const t = e.wait ?? { maxWaitTime: 60, minDelay: 2 }, n = await qn(e.client), i = [], a = /* @__PURE__ */ new Set();
  for (const r of e.tables) {
    const s = r.tableDefinition, o = s.globalSecondaryIndexes ?? [];
    if (!n.includes(r.tableName)) {
      await e.client.send(
        new Ye({
          TableName: r.tableName,
          AttributeDefinitions: s.attributeDefinitions,
          KeySchema: s.keySchema,
          BillingMode: s.billingMode,
          GlobalSecondaryIndexes: s.globalSecondaryIndexes
        })
      ), await Xe(
        { client: e.client, ...t },
        { TableName: r.tableName }
      ), i.push(r.tableName);
      continue;
    }
    if (o.length === 0)
      continue;
    const l = await J(e.client, r.tableName), m = jn(l);
    for (const c of o) {
      const u = c.IndexName ?? "";
      if (u.length === 0)
        continue;
      const d = m.get(u);
      if (!d) {
        await Ce({
          client: e.client,
          tableName: r.tableName,
          index: c,
          existingAttributeDefinitions: l.AttributeDefinitions,
          desiredTableAttributeDefinitions: s.attributeDefinitions,
          wait: t
        }), a.add(r.tableName);
        continue;
      }
      if (Ln({
        existing: d,
        desired: c
      }))
        continue;
      await Un({
        client: e.client,
        tableName: r.tableName,
        indexName: u,
        wait: t
      });
      const b = await J(e.client, r.tableName);
      await Ce({
        client: e.client,
        tableName: r.tableName,
        index: c,
        existingAttributeDefinitions: b.AttributeDefinitions,
        desiredTableAttributeDefinitions: s.attributeDefinitions,
        wait: t
      }), a.add(r.tableName);
    }
  }
  return {
    createdTables: i,
    updatedTables: Array.from(a.values())
  };
}, ti = async (e) => (await Hn(e)).createdTables, Qn = [
  {
    tableName: "user",
    tableDefinition: {
      attributeDefinitions: [
        { AttributeName: "id", AttributeType: "S" },
        { AttributeName: "email", AttributeType: "S" },
        { AttributeName: "username", AttributeType: "S" }
      ],
      keySchema: [{ AttributeName: "id", KeyType: "HASH" }],
      billingMode: "PAY_PER_REQUEST",
      globalSecondaryIndexes: [
        {
          IndexName: "user_email_idx",
          KeySchema: [{ AttributeName: "email", KeyType: "HASH" }],
          Projection: { ProjectionType: "ALL" }
        },
        {
          IndexName: "user_username_idx",
          KeySchema: [{ AttributeName: "username", KeyType: "HASH" }],
          Projection: { ProjectionType: "ALL" }
        }
      ]
    },
    indexMappings: [
      { indexName: "user_email_idx", partitionKey: "email" },
      { indexName: "user_username_idx", partitionKey: "username" }
    ]
  },
  {
    tableName: "session",
    tableDefinition: {
      attributeDefinitions: [
        { AttributeName: "id", AttributeType: "S" },
        { AttributeName: "userId", AttributeType: "S" },
        { AttributeName: "token", AttributeType: "S" },
        { AttributeName: "createdAt", AttributeType: "S" }
      ],
      keySchema: [{ AttributeName: "id", KeyType: "HASH" }],
      billingMode: "PAY_PER_REQUEST",
      globalSecondaryIndexes: [
        {
          IndexName: "session_userId_idx",
          KeySchema: [
            { AttributeName: "userId", KeyType: "HASH" },
            { AttributeName: "createdAt", KeyType: "RANGE" }
          ],
          Projection: { ProjectionType: "ALL" }
        },
        {
          IndexName: "session_token_idx",
          KeySchema: [
            { AttributeName: "token", KeyType: "HASH" },
            { AttributeName: "createdAt", KeyType: "RANGE" }
          ],
          Projection: { ProjectionType: "ALL" }
        }
      ]
    },
    indexMappings: [
      {
        indexName: "session_userId_idx",
        partitionKey: "userId",
        sortKey: "createdAt"
      },
      {
        indexName: "session_token_idx",
        partitionKey: "token",
        sortKey: "createdAt"
      }
    ]
  },
  {
    tableName: "account",
    tableDefinition: {
      attributeDefinitions: [
        { AttributeName: "id", AttributeType: "S" },
        { AttributeName: "userId", AttributeType: "S" },
        { AttributeName: "providerId", AttributeType: "S" },
        { AttributeName: "accountId", AttributeType: "S" }
      ],
      keySchema: [{ AttributeName: "id", KeyType: "HASH" }],
      billingMode: "PAY_PER_REQUEST",
      globalSecondaryIndexes: [
        {
          IndexName: "account_accountId_idx",
          KeySchema: [{ AttributeName: "accountId", KeyType: "HASH" }],
          Projection: { ProjectionType: "ALL" }
        },
        {
          IndexName: "account_userId_idx",
          KeySchema: [{ AttributeName: "userId", KeyType: "HASH" }],
          Projection: { ProjectionType: "ALL" }
        },
        {
          IndexName: "account_providerId_accountId_idx",
          KeySchema: [
            { AttributeName: "providerId", KeyType: "HASH" },
            { AttributeName: "accountId", KeyType: "RANGE" }
          ],
          Projection: { ProjectionType: "ALL" }
        }
      ]
    },
    indexMappings: [
      { indexName: "account_accountId_idx", partitionKey: "accountId" },
      { indexName: "account_userId_idx", partitionKey: "userId" },
      {
        indexName: "account_providerId_accountId_idx",
        partitionKey: "providerId",
        sortKey: "accountId"
      }
    ]
  },
  {
    tableName: "verification",
    tableDefinition: {
      attributeDefinitions: [
        { AttributeName: "id", AttributeType: "S" },
        { AttributeName: "identifier", AttributeType: "S" },
        { AttributeName: "createdAt", AttributeType: "S" }
      ],
      keySchema: [{ AttributeName: "id", KeyType: "HASH" }],
      billingMode: "PAY_PER_REQUEST",
      globalSecondaryIndexes: [
        {
          IndexName: "verification_identifier_idx",
          KeySchema: [
            { AttributeName: "identifier", KeyType: "HASH" },
            { AttributeName: "createdAt", KeyType: "RANGE" }
          ],
          Projection: { ProjectionType: "ALL" }
        }
      ]
    },
    indexMappings: [
      {
        indexName: "verification_identifier_idx",
        partitionKey: "identifier",
        sortKey: "createdAt"
      }
    ]
  }
], ni = Qn, ii = (e) => {
  if (e.length === 0)
    throw new Error("index resolver creation requires table schemas.");
  const t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  for (const i of e)
    for (const a of i.indexMappings) {
      const r = `${i.tableName}:${a.partitionKey}`;
      if (t.has(r))
        throw new Error(
          `Duplicate partition key mapping for ${i.tableName}.${a.partitionKey}.`
        );
      t.set(r, a);
      const s = `${i.tableName}:${a.indexName}`;
      if (n.has(s))
        throw new Error(
          `Duplicate index name mapping for ${i.tableName}.${a.indexName}.`
        );
      n.set(s, a);
    }
  return {
    indexNameResolver: ({ model: i, field: a }) => t.get(`${i}:${a}`)?.indexName,
    indexKeySchemaResolver: ({ model: i, indexName: a }) => {
      const r = n.get(`${i}:${a}`);
      if (r)
        return {
          partitionKey: r.partitionKey,
          sortKey: r.sortKey
        };
    }
  };
};
export {
  N as DynamoDBAdapterError,
  Hn as applyTableSchemas,
  Ee as convertToTableSchemas,
  Qn as coreTableSchemas,
  ii as createIndexResolversFromSchemas,
  ti as createTables,
  tt as defaultCompositeIndexes,
  nt as defaultSchemaExtensions,
  ei as dynamodbAdapter,
  Zn as generateTableSchemas,
  ni as multiTableSchemas
};
